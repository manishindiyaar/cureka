# Story 2.4: Vapi Webhook Handler for Real-time Events

**Epic**: Voice Assistant Integration
**Status**: Draft
**Story Type**: Backend Infrastructure

## Story Statement
As a backend developer,
I want to handle real-time Vapi webhook events to track voice session progress and store conversation history,
so that the mobile app can provide feedback about voice assistant behavior and maintain conversation records.

## Background
When the mobile app connects to Vapi, Vapi sends webhook events for:
- Conversation updates (transcripts, messages)
- Call status changes
- Function calls (when AI needs to perform actions)
- Error events
The backend needs to receive, process, and store these events.

## Acceptance Criteria
1. Create secure webhook endpoint `POST /api/v1/sessions/vapi/webhook`
2. Validate webhook signatures to ensure authenticity
3. Handle different event types (message, call-end, function-call)
4. Store conversation transcripts in database
5. Update session status in real-time
6. Handle function calls (like lookup_order, schedule_appointment)
7. Send relevant events to mobile app via webhook or WebSocket
8. Implement exponential backoff for failed webhooks
9. Add comprehensive logging for debugging

## Technical Implementation Notes

### Webhook Signature Validation
```typescript
// apps/api/src/api/v1/sessions/vapi/vapi.webhook.validation.ts
export const validateWebhookSignature = (payload: string, signature: string) => {
  const secret = process.env.VAPI_WEBHOOK_SECRET;
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature, 'hex'),
    Buffer.from(expectedSignature, 'hex')
  );
};
```

### Webhook Controller
```typescript
// apps/api/src/api/v1/sessions/vapi/vapi.webhook.controller.ts
import crypto from 'crypto';

export const handleVapiWebhook = async (req, res) => {
  const signature = req.headers['x-vapi-signature'];
  const payload = JSON.stringify(req.body);

  // Validate webhook authenticity
  if (!validateWebhookSignature(payload, signature)) {
    return res.status(401).json({
      success: false,
      code: 'INVALID_SIGNATURE',
      message: 'Webhook signature validation failed'
    });
  }

  const { type, data } = req.body;

  try {
    switch (type) {
      case 'message':
        await handleMessageEvent(data);
        break;

      case 'call-end':
        await handleCallEndEvent(data);
        break;

      case 'function-call':
        await handleFunctionCallEvent(data);
        break;

      case 'error':
        await handleErrorEvent(data);
        break;

      default:
        console.log(`Unknown webhook type: ${type}`);
    }

    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook processing error:', error);
    // Return 200 to prevent Vapi retry loop
    res.status(200).json({
      received: false,
      error: error.message
    });
  }
};

async function handleMessageEvent(data: any) {
  // Store conversation transcripts
  const { callId, role, transcript, timestamp } = data;

  await prisma.vapiMessages.create({
    data: {
      callId,
      role,
      transcript,
      timestamp: new Date(timestamp),
      metadata: { type: 'transcript' }
    }
  });

  // Forward to mobile app via WebSocket or push notification
  await notifyPatient(callId, {
    type: 'transcript',
    data: { role, transcript, timestamp }
  });
}

async function handleCallEndEvent(data: any) {
  const { id: sessionId, status, callStatus } = data;

  // Update session status
  await prisma.vapiSessions.update({
    where: { id: sessionId },
    data: {
      status: 'completed',
      endedAt: new Date(),
      metadata: { finalStatus: callStatus }
    }
  });

  // Calculate session summary
  const summary = await generateSessionSummary(sessionId);

  await notifyPatient(sessionId, {
    type: 'session_end',
    data: {
      sessionId,
      status: 'ended',
      summary
    }
  });
}

async function handleFunctionCallEvent(data: any) {
  const { callId, functionCall } = data;

  const result = await executeFunction(functionCall);

  return result;
}

async function executeFunction(functionCall: any) {
  const { name, parameters } = functionCall;

  switch (name) {
    case 'lookup_patient_info':
      return await lookupPatientInfo(parameters);

    case 'schedule_appointment':
      return await scheduleAppointment(parameters);

    case 'get_health_records':
      return await getHealthRecords(parameters);

    default:
      return { error: `Unknown function: ${name}` };
  }
}
```

### Database Schema Addition
```sql
-- Add to your existing schema
CREATE TABLE vapi_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL,
  role VARCHAR(50) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  transcript TEXT,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE vapi_sessions (
  id VARCHAR(255) PRIMARY KEY,
  patient_id UUID NOT NULL REFERENCES patients(id),
  status VARCHAR(50) NOT NULL,
  started_at TIMESTAMP WITH TIME ZONE NOT NULL,
  ended_at TIMESTAMP WITH TIME ZONE,
  transcript_summary TEXT,
  key_insights JSONB,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Route Registration
```typescript
// apps/api/src/api/v1/sessions/vapi/vapi.webhook.routes.ts
import { Router } from 'express';
import { handleVapiWebhook } from './vapi.webhook.controller.js';

const router = Router();

/**
 * POST /api/v1/sessions/vapi/webhook
 * Receive Vapi webhook events
 * No authentication required - Vapi signs webhooks
 */
router.post('/webhook', handleVapiWebhook);

export default router;
```

### Environment Variables
```env
# Vapi Webhook Configuration
VAPI_WEBHOOK_SECRET=your_webhook_secret_here
VAPI_WEBHOOK_URL=https://your-api.com/api/v1/sessions/vapi/webhook
```

### Testing Requirements
```javascript
// apps/api/sara_tests/test-vapi-webhook.js
const crypto = require('crypto');

async function testWebhookProcessing() {
  // Test message event
  const testMessage = {
    type: 'message',
    data: {
      callId: 'test-call-123',
      role: 'assistant',
      transcript: 'Hello, how can I help you today?',
      timestamp: Date.now()
    }
  };

  const signature = generateWebhookSignature(JSON.stringify(testMessage));

  const response = await makeRequest(
    '/api/v1/sessions/vapi/webhook',
    'POST',
    testMessage,
    { 'x-vapi-signature': signature }
  );

  assert(response.status === 200, 'Webhook should be processed');
  assert(response.body.received === true, 'Should confirm receipt');

  // Verify transcript was stored
  const transcript = await db.query('SELECT * FROM vapi_messages WHERE callId = ?', ['test-call-123']);
  assert(transcript.length === 1, 'Message should be stored');
}
```

### Security Considerations
- Webhook signatures are mandatory
- Rate limiting should be applied (50 requests/minute)
- No sensitive data should be stored in plaintext
- Webhook URLs should be kept secret

## Technical Context

The webhook system acts as the real-time communication layer between Vapi and your backend, enabling:
- Conversation history preservation
- Patient notification via WebSocket
- Analytics and insights generation
- Integration with existing healthcare systems

This completes the voice integration architecture by creating a bidirectional event system between the mobile app, backend, and Vapi servers.